<!DOCTYPE html>
<!--[if lt IE 7]><html lang="ru" class="lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html lang="ru" class="lt-ie9 lt-ie8"><![endif]-->
<!--[if IE 8]><html lang="ru" class="lt-ie9"><![endif]-->
<!--[if gt IE 8]><!-->
<html lang="ru">
<!--<![endif]-->
<head>
	<meta charset="utf-8" />
	<title>Диаграммы прецедентов</title>
	<meta name="description" content="" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<link rel="shortcut icon" href="favicon.ico" />
	<link rel="stylesheet" href="libs/font-awesome-4.2.0/css/font-awesome.min.css" />
	<link rel="stylesheet" href="fonts.css" />
	<link rel="stylesheet" href="main.css" />
	<link rel="stylesheet" href="media.css" />
</head>
<body>
	<div id="page-wrapper">
		<header role="banner">
			<a href='index.html'>
				<h1>Unified Modeling Language<br/>UMLВВЕДЕНИЕ</h1>
				<hr class="left"> 
				<hr class="right">
			</a>
			<div class="quotes">UML &mdash; унифицированный язык моделирования, который является графическим языком для спецификации, визуализации, проектирования и документирования систем.</div>
		</header>
		
		<div class="main" role="main">
			<section>
				<h3>Несколько слов о требованиях</h3>
				<p>
					Итак, поговорим о требованиях. Что это такое, мы, в общем, понимаем &mdash; когда заказчик 
					описывает нам, чего же именно он хочет, мы всегда слышим фразы типа <q>хотелось бы, чтобы 
					проверка обновлений проводилась автоматически, как в антивирусах</q>, <q>хочу большую 
					зеленую кнопку в центре окна, которая начинает процесс</q>, <q>программа должна позволять 
					просматривать и печатать отчеты</q>, <q>и чтоб красивенько все было, с полупрозрачностями, 
					как в Висте</q>, <q>при выходе должно выводиться подтверждение</q> и т. д. и т. п. Конечно, 
					как настоящие разработчики, мы понимаем и то, что заказчик никогда не знает, что именно ему 
					нужно, а если понимает, то объяснить не может. Но ведь фразы-то всегда, по сути, одинаковы! 
					Они описывают, как заказчик представляет себе систему, чего заказчик хочет от системы, 
					функциональность, которой он от нее ожидает, требования, которые к ней предъявляет.
				</p>
				<p>
					Если обратиться к классикам, например, к той же <q>банде трех</q> (Якобсон, Буч, Рамбо), мы 
					узнаем, что требование &mdash; это желаемая функциональность, свойство или поведение 
					системы. Именно со сбора требований начинается процесс разработки ПО. Если изобразить 
					процесс разработки ПО в виде <q>черного ящика</q> (уверены, читатель знает, что это такое, 
					если нет &mdash; <a href="https://www.wikipedia.org" title="Wikipedia" target="_blank"><q>Википедия</q></a> 
					к вашим услугам), на выходе которого мы получаем программный продукт, то на вход этого 
					<q>черного ящика</q> будет подаваться именно набор требований к программному продукту 
					(рис. 6.1)!
				</p>
				<figure>
					<img src="index_use_case_diagram/06_01_uml.gif" alt="picture is missing" title="Пример диаграммы прецедентов" width="620" height="87">
						<figcaption>Рисунок 6.1</figcaption>
				</figure>
				<p>
					Кстати, какую диаграмму напоминает этот рисунок? Правильно, диаграмму активностей. И выбор 
					именно этой диаграммы тут абсолютно оправдан &mdash; помните, мы говорили, что диаграммы 
					активностей часто используют для описания бизнес-процессов? Единственный нюанс: обычно 
					процесс разработки не заканчивается с выпуском программного продукта &mdash; грядет новая 
					итерация, новые, уточненные требования, новая версия и т. д.
				</p>
				<p>
					Кстати, вернемся к требованиям. Да, мы сказали, что на вход нашего <q>черного ящика</q> 
					подается набор требований. Но в какой форме? Как их документируют, эти требования? Думаю, 
					большинство читателей помнит, что такое техническое задание &mdash; основной документ, без 
					составления которого не начинался в советские времена ни один проект. Документ это был 
					большой, многостраничный, с четкой структурой, определяемой <abbr title="Государственными отраслевыми стандартами">ГОСТами</abbr>. 
					И описывал он, по сути, не что иное, как требования к создаваемой системе!
				</p>
				<p>
					<em>Техническое задание</em> &mdash; вещь по-своему хорошая. Но время шло, менялись 
					стандарты, нотации, способы описания требований. И вот постепенно техническое задание 
					уступило место набору артефактов, состоящему из документов двух видов:
				</p>
				<ul>
					<li>диаграммы прецедентов;</li>
					<li>нефункциональные требования.</li>
				</ul>
				<p>
					Диаграммы прецедентов составляют модель прецедентов (вариантов использования, use-cases). 
					<em>Прецедент &mdash; это функциональность системы, позволяющая пользователю получить некий 
					значимый для него, ощутимый и измеримый результат</em>. Каждый прецедент соответствует 
					отдельному сервису, предоставляемому моделируемой системой в ответ на запрос пользователя, 
					т. е. определяет способ использования этой системы. Именно по этой причине use-cases, или 
					прецеденты, часто в русской терминологии фигурируют как варианты использования. Варианты 
					использования чаще всего применяются для спецификации внешних требований к проектируемой 
					системе или для спецификации функционального поведения уже существующей системы. Кроме этого, 
					варианты использования неявно описывают типичные способы взаимодействия пользователя с 
					системой, позволяющие корректно работать с предоставляемыми системой сервисами.
				</p>
				<p>
					<em>Нефункциональные требования </em> &mdash; это описание таких свойств системы, как 
					особенности среды и реализации, производительность, расширяемость, надежность и т. д. Часто 
					нефункциональные требования не привязаны к конкретному варианту использования и потому выносятся 
					в отдельный список дополнительных требований к системе (рис. 6.2).
				</p>
				<figure>
					<img src="index_use_case_diagram/06_02_uml.gif" alt="picture is missing" title="Пример нефункциональных требований на диаграмме прецедентов" width="536" height="389">
						<figcaption>Рисунок 6.2</figcaption>
				</figure>
				<p>
					Но вернемся же к прецедентам (вариантам использования). Идентифицировать прецеденты и 
					действующие лица &mdash; обязанность системного аналитика. И делает он это для того, чтобы:
				</p>
				<ul>
					<li>четко разграничить систему и ее окружение;</li>
					<li>
						определить, какие действующие лица и как именно взаимодействуют с системой, какой 
						функционал (варианты использования) ожидается от системы;
					</li>
					<li>
						определить и описать в словаре предметной области (глоссарии) общие понятия, которые 
						необходимы для детального описания функционала системы (прецедентов).
					</li>
				</ul>
				<p>
					Подобный вид деятельности обычно выполняется в такой последовательности:
				</p>
				<ol>
					<li>Определение действующих лиц.</li>
					<li>Определение прецедентов.</li>
					<li>Составление описания каждого прецедента.</li>
					<li>
						Описание модели прецедентов в целом (этот этап включает в себя создание словаря предметной 
						области).
					</li>
				</ol>
				<p>
					Вначале требования оформляются в виде обычного текстового документа, который создается или 
					самим пользователем, или пользователем и разработчиком вместе. Далее требования оформляют в 
					виде таблицы. В левую колонку помещают прецеденты, а в правую &mdash; действующих лиц, 
					участвующих в прецеденте.
				</p>
				<p>
					Рассмотрим пример. Секретарь размещает на сервере меню обеденных блюд на неделю. Сотрудники 
					должны иметь возможность ознакомиться с меню и сделать заказ, выбрав блюда на каждый день 
					следующей недели. Офис-менеджер должен иметь возможность сформировать счет и оплатить его. 
					Система должна быть написана на ASP.NET. Такое вот нехитрое интернет-приложение для 
					автоматизации заказов обедов в офис.
				</p>
				<p>
					Думаем, здесь все понятно. Таблица с описанием требований может быть, например, такой:
				</p>
				<table>
					<capture>Таблица 6.1</capture>
					<tr>
						<th>Прецедент</th>
						<th>Действующее лицо</th>
					</tr>
					<tr>
						<td>разместить меню</td>
						<td>секретарь</td>
					</tr>
					<tr>
						<td>ознакомиться с меню</td>
						<td>сотрудник, секретарь, офис-менеджер</td>
					</tr>
					<tr>
						<td>сделать заказ</td>
						<td>сотрудник, секретарь, офис-менеджер</td>
					</tr>
					<tr>
						<td>сформировать счет</td>
						<td>офис-менеджер</td>
					</tr>
					<tr>
						<td>оплатить счет</td>
						<td>офис-менеджер</td>
					</tr>
				</table>
				<p>
					Здесь нигде не сказано о том, что система должна быть написана на ASP.NET. Почему &mdash; 
					понятно: это ведь нефункциональное требование! И еще, очевидно, что секретарь и офис-менеджер 
					тоже являются сотрудниками. Читатель, внимательно прочитавший предыдущие лекции, заподозрит, 
					что в данном случае, создавая модель прецедентов, говоря о действующих лицах, можно бы применить 
					генерализацию. Действительно, диаграмма прецедентов, построенная на основе этой таблицы, может 
					быть, например, такой (рис. 6.3):
				</p>
				<figure>
					<img src="index_use_case_diagram/06_03_uml.gif" alt="picture is missing" title="Пример диаграммы прецедентов" width="620" height="474">
						<figcaption>Рисунок 6.3</figcaption>
				</figure>
			</section>
			<section>
				<h3>Диаграммы прецедентов и их нотация</h3>
				<p>
					Что ж, у нас есть пример диаграммы. Итак, какие же элементы мы на ней видим? Первое, что 
					бросается в глаза, &mdash; большой прямоугольник, внутри которого размещаются эллипсы, 
					обозначающие, как мы уже поняли, прецеденты. В верхней части прямоугольника указано название 
					моделируемой системы, а называют его <em>рамками системы</em> (system boundary, subject boundary), 
					контекстом или просто системой. Этот элемент диаграммы показывает границу между тем, что вы как 
					аналитик показали в виде прецедентов (внутри этих рамок), и тем, что вы изобразили как 
					действующие лица (вне их). Чаще всего таким прямоугольником показывают границы самой 
					моделируемой системы. То есть внутри границы находятся прецеденты &mdash; тот функционал, 
					который реализует система (и в этом смысле прецеденты могут рассматриваться как представления 
					подсистем и классов модели), а снаружи &mdash; действующие лица: пользователи и другие внешние 
					сущности, взаимодействующие с моделируемой системой.
				</p>
				<p>
					Следует сказать, что рамки системы на диаграммах прецедентов изображают довольно редко, т. к. 
					они неявно подразумеваются самой диаграммой. По сути, этот элемент не привносит в диаграмму 
					какой-либо дополнительной значимой информации, так что его использование &mdash; дело вкуса 
					аналитика. Появление рамок системы на диаграмме прецедентов чаще всего диктуется особенностями 
					персонального стиля проектирования.
				</p>
				<p>
					Кроме рамок системы или ее контекста на диаграмме мы видим еще два вида связанных с ней 
					сущностей &mdash; это действующие лица (экторы, actors) и прецеденты. Начнем с экторов. Довольно 
					часто в русскоязычной литературе по UML для обозначения действующих лиц можно встретить термин 
					<q>актер</q>. В принципе, смысл его более-менее понятен и оригинальному английскому термину он 
					созвучен. Более того, есть еще одна причина такого перевода. Какое слово первым приходит к вам в 
					голову, когда вы слышите слово <q>актер</q>? Да, конечно же &mdash; слово <q>роль</q>! Именно о 
					ролях мы вскоре и поговорим, когда будем пытаться разобраться, что скрывается за понятием 
					<q>действующее лицо</q>. А пока, да простит нас читатель, далее мы все же будем пользоваться 
					словом <q>эктор</q> &mdash; транскрипцией оригинального термина. Помнится, мы уже как-то писали 
					о нашем отношении к буквальному переводу терминологии...
				</p>
				<p>
					Итак, какой же смысл вкладывают в понятие эктора? Эктор &mdash; это набор ролей, которые 
					исполняет пользователь в ходе взаимодействия с некоторой сущностью (системой, подсистемой, 
					классом). Эктор может быть человеком, другой системой, подсистемой или классом, которые 
					представляют нечто за пределами рассматриваемой сущности. Экторы <q>общаются</q> с системой 
					путем обмена сообщениями. Четко выделив экторов, вы тем самым ясно определяете границу между 
					тем, что внутри системы, и тем, что снаружи, &mdash; рамки системы.
				</p>
				<p>
					Возможно, слова <q>роли, исполняемые пользователем</q> в определении эктора звучат не очень 
					понятно. Очень забавно это понятие объясняется в Zicom Mentor:
				</p>
				<cite title="Zicom Mentor">
					роль &mdash; это не конкретный пользователь, а подобие шляпы, которую человек надевает, когда 
					взаимодействует с сущностью.
				</cite>
				<p>
					Действительно, наденьте шляпу пирата &mdash; и вы капитан Джек Воробей, а наденьте цилиндр и 
					вы &mdash; Джек-потрошитель! Шутка... <q>Физический</q> пользователь может играть роль одного 
					или даже нескольких экторов, выполняя их функции в ходе взаимодействия с системой. И наоборот, 
					роль одного и того же эктора может выполняться несколькими пользователями.
				</p>
				<p>
					На диаграммах UML экторы изображаются в виде стилизованных человечков, ведь, как вы, конечно, 
					помните, идея была в создании нотации, любой символ которой легко может быть изображен от руки 
					(рис. 6.4):
				</p>
				<figure>
					<img src="index_use_case_diagram/06_04_uml.gif" alt="picture is missing" title="Эктор на диаграмме прецедентов" width="70" height="114">
						<figcaption>Рисунок 6.4</figcaption>
				</figure>
				<p>
					Несмотря на <q>человеческий</q> вид этого обозначения, не следует забывать, что экторы &mdash; 
					это не обязательно люди. Эктором, как мы уже говорили ранее, может быть внешняя система, 
					подсистема, класс и т. д. Кстати, человечек ( <q>stick-person</q> ) &mdash; это не единственное 
					обозначение эктора, используемое в UML. На диаграммах прецедентов обычно применяется именно 
					<q>человекоподобная</q> форма эктора, но на других диаграммах, и особенно в случаях, когда эктор 
					имеет атрибуты, которые важно показать, используется изображение эктора как класса со 
					стереотипом &lt;&lt;actor&gt;&gt; (рис. 6.5):
				</p>
				<figure>
					<img src="index_use_case_diagram/06_05_uml.gif" alt="picture is missing" title="Эктор на диаграмме прецедентов" width="124" height="97">
						<figcaption>Рисунок 6.5</figcaption>
				</figure>
				<p>
					С системой экторы, как мы уже сказали, общаются через сообщения, но если говорить на более 
					высоком уровне абстракции, в терминах модели прецедентов, то взаимодействуют они с системой 
					через прецеденты. Один и тот же эктор может быть связан с несколькими прецедентами, и наоборот, 
					один прецедент может быть связан с несколькими разными экторами. Ассоциации между эктором и 
					прецедентом <em>всегда бинарные</em> &mdash; т. е. представляют отношения типа <q>один к одному</q>, 
					использование кратности недопустимо. Это не противоречит сказанному выше: действительно, один 
					эктор может быть связан с несколькими прецедентами, но только с помощью отдельных ассоциаций &mdash; 
					по одной на каждый прецедент. Мы видели это в нашем примере. Кстати, там мы видели ассоциации, 
					изображенные не просто в виде линий, а стрелками. Думаем, смысл этого обозначения вполне понятен: 
					это направленная ассоциация и стрелка (как и на других диаграммах) всегда направлена в сторону 
					той сущности, от которой что-то требуют, чьим сервисом пользуются и т. д.
				</p>
				<p>
					И еще &mdash; экторы не могут быть связаны друг с другом. Единственное допустимое отношение 
					между экторами &mdash; <em>генерализация (наследование)</em>. Опять-таки, в нашем примере с 
					заказом обедов в офис, вы могли увидеть именно такой вид отношений между экторами. Это не 
					значит, что в реальной жизни офис-менеджер и секретарь (да и вообще любые два сотрудника) не 
					могут общаться: просто при создании модели прецедентов такое общение не попадает в область 
					наших интересов, считается несущественным.
				</p>
				<p>
					Еще один тип элементов, встречающийся на диаграммах прецедентов, более того, давший им название, 
					&mdash; это собственно прецеденты, или варианты использования. <em>Прецедент &mdash; это описание 
					набора последовательных событий (включая возможные варианты), выполняемых системой, которые 
					приводят к наблюдаемому эктором результату</em>. Прецеденты описывают сервисы, предоставляемые 
					системой экторам, с которыми она взаимодействует. Причем прецедент никогда не объясняет, 
					<q>как</q> работает сервис, а только описывает, <q>что</q> делается.
				</p>
				<p>
					Изображаются прецеденты в виде эллипса, внутрь контура которого помещается имя (описание) 
					прецедента. Имя прецедента обычно намного длиннее имен других элементов модели. Почему это 
					так, в принципе, понятно: имя прецедента описывает взаимодействие эктора с системой, говорит 
					о том, какими сообщениями они обмениваются между собой. В нашем примере с заказом обедов мы 
					видели несколько прецедентов и наверняка читатель заметил, что имя прецедента &mdash; это, 
					скорее, название сценария, воспроизводящегося в ходе взаимодействия эктора с системой. Причем 
					это всегда описание с точки зрения эктора, описание услуг, предоставляемых системой 
					пользователю. Приведем пример простейшей диаграммы, иллюстрирующей сказанное нами об 
					обозначениях прецедента (рис. 6.6).
				</p>
				<figure>
					<img src="index_use_case_diagram/06_06_uml.gif" alt="picture is missing" title="Прицедент на диаграмме прецедентов" width="441" height="267">
						<figcaption>Рисунок 6.6</figcaption>
				</figure>
				<p>
					В этом примере пассажир может купить в сервисной кассе билет на некоторый вид транспорта. 
					Покупка билета &mdash; это название сценария, по которому эктор (пассажир) может 
					взаимодействовать с системой (кассой). Заметьте, это не описание сценария, а именно название 
					&mdash; оно говорит нам, что делает эктор в процессе взаимодействия, но не говорит, как именно! 
					И еще &mdash; прецеденты определяют непересекающиеся сценарии поведения. Выполнение одного 
					прецедента не может быть прервано в результате работы другого прецедента. Другими словами, 
					выполнение одного прецедента не может быть прервано в результате событий или действий, вызванных 
					выполнением другого прецедента. Прецеденты выступают как атомарные транзакции, выполнение 
					которых не может быть прервано.
				</p>
				<p>
					Внимательный читатель, возможно, отметил то, как незаметно мы ввели в употребление слово 
					<q>сценарий</q>. Что же такое сценарий и как понятие сценария связано с понятием прецедента? На 
					первый вопрос хорошо отвечают классики (Г. Буч):
				</p>
				<cite title="Grady Booch">
					Сценарий &mdash; это конкретная последовательность действий, иллюстрирующая поведение.
				</cite>
				<p>
					Сценарий &mdash; это повествовательный рассказ о совершаемых эктором действиях, история, эпизод, 
					происходящий в данных временных рамках и данном контексте взаимодействия. Сценарии (в различных 
					формах представления) широко применяются в процессе разработки программного обеспечения. Как мы 
					уже только что отметили, написание сценария напоминает написание художественного рассказа, и 
					этим объясняется тот факт, что использование сценариев широко распространено среди аналитиков, 
					которые часто обладают художественными или литературными способностями. Несмотря на непрерывный 
					повествовательный характер, сценарии можно рассматривать как последовательности действий (делать 
					раскадровку). При разработке пользовательского интерфейса сценарии описывают взаимодействие 
					между пользователем (или категорией пользователей, например, администраторами системы, конечными 
					пользователями) и системой. Такой сценарий состоит из последовательного описания комбинаций 
					отдельных действий и задач (например, нажатий клавиш, щелчков по элементам управления, ввода 
					данных в соответствующие поля и т. д.). Вспомните, к примеру, описания последовательностей 
					действий пользователя (предназначенных для достижения определенных результатов, решения 
					определенных задач), которые вы находите в справке к малознакомой программе. То же самое можно 
					сказать о модных сейчас <q>how-to videos</q>, в которых такие последовательности отображаются 
					визуально, на конкретных примерах. В любом случае, цель подобных справочных материалов &mdash; 
					предоставить описание типичных сценариев использования системы, сценариев взаимодействия между 
					пользователем и системой.
				</p>
				<p>
					Сценарии также иногда можно увидеть на диаграмме прецедентов. Иногда их изображают в виде 
					<q>листа бумаги</q>, на котором написано имя файла, &mdash; прямоугольника с загнутым нижним 
					левым уголком. В этом случае указанный файл содержит в себе описание данного сценария. А 
					иногда сценарий записывается в комментарий. Как вы, наверное, помните, комментарии (ноутсы, 
					notes) изображаются прямоугольниками с загнутым верхним правым углом и соединяются с элементом, 
					который они поясняют, пунктирной линией (рис. 6.7).
				</p>
				<figure>
					<img src="index_use_case_diagram/06_07_uml.gif" alt="picture is missing" title="Сценарий на диаграмме прецедентов" width="609" height="202">
						<figcaption>Рисунок 6.7</figcaption>
				</figure>
				<p>
					Как мы уже упоминали, сценарии могут быть записаны в различных формах. Это может быть 
					структурированный, но неформализованный текст, формализованный структурированный текст, 
					псевдокод, таблица, диаграмма активностей, наконец! Каждый сценарий описывает в 
					повествовательной форме завершенное, конкретное взаимодействие, имеющее с точки зрения 
					пользователя определенную цель. Если рассматривать табличную форму представления сценария, то 
					линия, разделяющая левый и правый столбцы таблицы, символизируют собой границу, отделяющую 
					действия пользователя от ответных действий системы. Табличная форма особо подчеркивает участие 
					пользователя, что является очень важным аспектом при разработке пользовательского интерфейса.
				</p>
				<p>
					Вот пример простого (неформализованного) текстового описания сценария.
				</p>
				<p>
					Пользователь вводит логин, пароль, адрес электронной почты и код подтверждения и нажимает кнопку 
					<q>Далее</q>. Система запрашивает ввод проверочного кода. Пользователь вводит код и нажимает 
					кнопку <q>Далее</q>. Система проверяет соответствие кода изображенному на картинке.
				</p>
				<p>
					Не правда ли, знакомая процедура? Да, это описание регистрации пользователя на некотором сайте. 
					Правда, не совсем полное: не рассмотрены случаи, когда выбранный пользователем логин уже занят, 
					адрес электронной почты введен неправильно, пароль не удовлетворяет требованиям или код не 
					соответствует изображенному на картинке. О таких случаях &mdash; альтернативных сценариях 
					&mdash; мы поговорим чуть позже.
				</p>
				<p>
					А вот тот же сценарий в табличном представлении:
				</p>
				<table>
					<tr>
						<th>Действия пользователя</th>
						<th>Реакция системы</th>
					</tr>
					<tr>
						<td>Ввод логина, пароля, адреса электронной почты и нажатие кнопки <q>Далее</q></td>
						<td>Запрос ввода проверочного кода</td>
					</tr>
					<tr>
						<td>Ввод проверочного кода и нажатие кнопки <q>Далее</q></td>
						<td>Проверка кода на соответствие изображенному на картинке</td>
					</tr>
				</table>
				<p>
					Вы, конечно, заметили, что этот сценарий можно детализировать &mdash; например, прежде чем 
					попросить ввести проверочный код, система отображает картинку, на которой этот самый код 
					изображен. Т. е. запрос на ввод кода включает в себя вывод картинки с упомянутым кодом. Об этом 
					мы тоже еще поговорим.
				</p>
				<p>
					А пока попробуем ответить на второй вопрос, а именно: как связаны понятия сценария и прецедента. 
					Прецеденты, как мы уже говорили, рождаются из требований к системе. Но говорят они о том, что 
					делает система. Как система это делает, говорят сценарии. Таким образом, прецедент можно 
					специфицировать путем описания потока действий или событий в текстовой форме &mdash; в виде, 
					понятном для <q>постороннего</q> (не занятого в непосредственной разработке системы) читателя. А 
					ведь такое описание &mdash; это и есть сценарий! Таким образом, сценарии специфицируют 
					прецеденты. И еще. Поскольку сценарии &mdash; это, по сути, рассказы, они являются весьма 
					эффективным средством извлечения информации из бесед с заказчиком и предоставляют превосходное, 
					понятное непрофессионалу описание создаваемого приложения. Сценарии, да и вообще диаграммы 
					прецедентов (дополненные сценариями) являются отличным средством общения между разработчиками и 
					заказчиком, причем, в силу простоты нотации, &mdash; средством, понятным обеим сторонам. В 
					конечном итоге, взаимосвязь между требованиями, прецедентами и сценариями можно изобразить 
					такой <q>псевдодиаграммой</q> (рис. 6.8).
				</p>
				<figure>
					<img src="index_use_case_diagram/06_08_uml.gif" alt="picture is missing" title="Взаимосвязь между требованиями, прецедентами и сценариями">
						<figcaption>Рисунок 6.8</figcaption>
				</figure>
				<p>
					Как видите, для каждой ассоциации на диаграмме проставлена кратность и ее смысл вполне понятен, 
					но все же о кратности следует поговорить отдельно. Один прецедент определяет несколько сценариев, 
					каждый из которых представляет один из возможных вариантов определяемого прецедентом потока 
					событий. Сценарии так же соотносятся с прецедентами, как экземпляры класса, т.е. сценарий &mdash; 
					это экземпляр прецедента, как объект &mdash; экземпляр класса. Система может содержать, 
					например, несколько десятков прецедентов, каждый из которых, в свою очередь, может 
					разворачиваться в десятки сценариев. Как правило, прецедент описывает не одну последовательность 
					действий, а множество, и выразить все детали рассматриваемого прецедента с помощью одной 
					последовательности действий обычно не получается. Практически для любого прецедента можно 
					выделить основной сценарий, описывающий <q>нормальную</q> последовательность действия, и 
					вспомогательные, описывающие альтернативные последовательности, которые инициируются в случае 
					возникновения определенных условий.
				</p>
				<p>
					Другой вопрос: требуется ли такое уточнение модели прецедентов, оправдано ли оно для данного 
					уровня приближения, или <q>подразумевающиеся</q> альтернативные сценарии можно опустить? 
					Например, в предыдущем примере с покупкой билета в сервисной кассе мы не изобразили сценарии (и, 
					соответственно, прецеденты), соответствующие вариантам, когда билетов на выбранный пассажиром 
					рейс уже не осталось, пассажир изменил свое решение и хочет взять билет на другой рейс, когда 
					оплата идет наличными или по кредитной карте и т. д.
				</p>
				<p>
					<q>Хватит ходить вокруг да около!</q> &mdash; воскликнет нетерпеливый читатель. Уже заканчиваем. 
					Мы просто хотели мягко подвести читателя к вопросу об отношениях между прецедентами. А отношения 
					эти весьма многообразны. Начнем со старого знакомого &mdash; отношения обобщения (наследования, 
					генерализации). О генерализации мы уже говорили не раз, когда рассматривали диаграммы классов. 
					Но все же напомним суть этого понятия. Как говорят классики, обобщение &mdash; это отношение 
					специализации (обобщения), в котором объекты специализированного элемента (потомка) могут быть 
					подставлены вместо объектов обобщенного элемента (родителя, или предка).
				</p>
				<p>
					Точно так же, как мы обычно поступаем с классами, после того как мы выделили и описали каждый 
					прецедент, мы должны просмотреть их все на предмет наличия одинаковых действий &mdash; поискать, 
					а не выполняются ли (используются) некоторые действия совместно несколькими вариантами 
					использования. Этот совместно используемый фрагмент лучше описать в отдельном прецеденте. Таким 
					образом мы уменьшим избыточность модели за счет применения обобщения прецедентов (иногда, правда, 
					говорят не об обобщении, а об использовании прецедентов; почему &mdash; сейчас поймете). Как это 
					и <q>положено</q> при наследовании, экземпляры обобщенных прецедентов (потомков) сохраняют 
					поведение, присущее обобщающему прецеденту (предку). Другими словами, наличие (использование) в 
					варианте использования X обобщенного варианта использования Y говорит нам о том, что экземпляр 
					прецедента X включает в себя поведение прецедента Y. Обобщения применяются, чтобы упростить 
					понимание модели вариантов использования за счет многократного задействования <q>заготовок</q> 
					прецедентов для создания прецедентов, необходимых заказчику (помните, как мы рассматривали 
					вопрос о том, всегда ли необходимо создавать новый класс, или лучше воспользоваться готовым 
					решением, чувствуете аналогию?). Такие <q>полные</q> прецеденты называются <em>конкретными 
					прецедентами</em>. <q>Заготовки</q> прецедентов, созданные лишь для многократного 
					использования в других прецедентах, называют <em>абстрактными прецедентами</em>. Абстрактный 
					прецедент (как и абстрактный класс) не существует сам по себе, но экземпляр конкретного 
					прецедента демонстрирует поведение, описываемое абстрактными прецедентами, которые он (повторно) 
					использует. Прецедент, который экторы наблюдают при взаимодействии с системой (<q>полный</q> 
					прецедент, как мы называли его ранее), часто называют еще <q>реальным</q> прецедентом.
				</p>
				<p>
					Как мы уже говорили выше, обобщение (наследование) чаще всего используют между классами и 
					интерфейсами. Однако другие элементы модели также могут находиться между собой в отношении 
					наследования &mdash; например, пакеты (о которых мы тут не говорим), экторы, прецеденты...
				</p>
				<p>
					Изображается обобщение, как, конечно, помнит внимательный читатель, линией с 
					<q>незакрашенной</q> треугольной стрелкой на конце. Обобщение &mdash; это отношение между 
					предком и потомком, и стрелка всегда указывает на предка. Если вспомнить, что потомки наследуют 
					(используют) свойства предка, то вполне логично вспоминается наше утверждение о том, что стрелки 
					в UML всегда направлены в сторону того, от кого что-то требуют, чьими сервисами пользуются 
					(рис. 6.9):
				</p>
				<figure>
					<img src="index_use_case_diagram/06_09_uml.gif" alt="picture is missing" title="Обобщение на диаграмме прецедентов">
						<figcaption>Рисунок 6.9</figcaption>
				</figure>
				<p>
					Как мы уже говорили ранее и видели в нашем первом примере диаграммы прецедентов, обобщение может 
					использоваться для создания различных разновидностей экторов. Экторы-потомки наследуют от предка 
					базовые характеристики и дополняют их своей спецификой. Точно так же прецедент-потомок наследует 
					поведение и семантику прецедента-родителя и дополняет его поведение.
				</p>
				<p>
					Следующий вид отношений между прецедентами &mdash; включение. Отношение включения означает, что 
					в некоторой точке базового прецедента содержится поведение другого прецедента. Включаемый 
					прецедент не существует сам по себе, а является всего лишь частью объемлющего прецедента. Таким 
					образом, базовый прецедент как бы заимствует поведение включаемых, раскладываясь на более 
					простые прецеденты. Например, когда мы покупаем в магазине некоторую вещь, в момент считывания 
					кассиром штрих-кода обновляется состояние базы данных товаров, имеющихся в наличии, &mdash; 
					количество наличных единиц купленного товара уменьшается. То же самое действие выполняется и в 
					том случае, если купленный товар оказался бракованным, непригодным к использованию или попросту 
					нам не понравился: состояние упомянутой базы данных вновь обновляется &mdash; но теперь уже в 
					сторону увеличения количества наличных единиц определенного товара. Т. е. оба этих действия 
					&mdash; и покупка, и возврат &mdash; содержат (включают в себя) такое действие, как обновление 
					содержимого БД.
				</p>
				<p>
					А как же изображается включение? Да очень просто &mdash; как зависимость (пунктирная линия со 
					стрелкой, помните?) со стереотипом &laquo;include&raquo;. При этом стрелка направлена, 
					естественно, в сторону включаемого прецедента. Этот факт легко объяснить, если вспомнить 
					утверждение, которое мы уже несколько раз использовали в этом курсе: стрелка всегда направлена в 
					сторону того элемента, от которого что-то требуется, чьими сервисами пользуются. А если считать, 
					что объемлющий прецедент включает в себя, заимствует (использует) поведение включаемых 
					прецедентов, становится ясно, что стрелка может быть направлена только таким образом. А вот и 
					диаграмма, иллюстрирующая вышесказанное, которую мы позаимствовали из Zicom Mentor (рис. 6.10):
				</p>
				<figure>
					<img src="index_use_case_diagram/06_10_uml.gif" alt="picture is missing" title="Включение на диаграмме прецедентов">
						<figcaption>Рисунок 6.10</figcaption>
				</figure>
				<p>
					Как хорошо видно из этого примера, использование включения позволяет избежать многократного 
					описания одного и того же набора действий &mdash; общее поведение можно просто описать в виде 
					прецедента, включаемого в базовые.
				</p>
				<p>
					На очереди &mdash; <em>отношение расширения</em>. Чтобы уяснить себе смысл расширения, 
					представим себе, что мы говорим об оплате некоторого купленного нами товара. Мы можем оплатить 
					товар наличными, если сумма не превышает &#36;100. Или оплатить кредитной картой, если сумма 
					находится в пределах от &#36;100 до &#36;1000. Если же сумма превышает &#36;1000, нам придется 
					брать кредит. Таким образом мы расширили понимание операции оплаты купленного товара и на случаи, 
					когда используются другие средства оплаты, нежели наличные. Но сами эти случаи возникают только 
					при строго определенных условиях: когда цена товара попадает в определенные рамки.
				</p>
				<p>
					Расширение дополняет прецедент другими прецедентами, <q>срабатывающими</q> при некоторых 
					условиях, &mdash; просто добавляет в исходный прецедент последовательность действий, 
					содержащуюся в другом прецеденте. Отношение расширения прецедента <em>А</em> к прецеденту 
					<em>В</em> означает, что экземпляр прецедента <em>В</em> может включать в себя (при 
					определенных условиях, которые могут быть описаны в расширении; как именно описаны, мы 
					скажем чуть позже) поведение, описанное в прецеденте <em>А</em>. Пример показан на следующей 
					диаграмме (рис. 6.11): Расширение дополняет прецедент другими прецедентами, 
					<q>срабатывающими</q> при некоторых условиях, &mdash; просто добавляет в исходный прецедент 
					последовательность действий, содержащуюся в другом прецеденте. Отношение расширения прецедента 
					<em>А</em> к прецеденту <em>В</em> означает, что экземпляр прецедента <em>В</em> может 
					включать в себя (при определенных условиях, которые могут быть описаны в расширении; как именно 
					описаны, мы скажем чуть позже) поведение, описанное в прецеденте <em>А</em>. Пример показан на 
					следующей диаграмме (рис. 6.11):
				</p>
				<figure>
					<img src="index_use_case_diagram/06_11_uml.gif" alt="picture is missing" title="Расширение на диаграмме прецедентов">
						<figcaption>Рисунок 6.11</figcaption>
				</figure>
				<p>
					Однако в приведенном примере не видно, при каких именно условиях человек использует каждый 
					конкретный способ оплаты. В то же время, при моделировании с использованием расширения можно 
					указать как условия осуществления расширенного поведения, так и место &mdash; точку расширения 
					прецедента, в которой подключаются действия из расширяющих прецедентов. Вспомните оператор 
					безусловного перехода, который вы, надеемся, использовали в своих программах не слишком часто. 
					Как только интерпретатор доходит до этого оператора, он передает управление на строку, которая 
					помечена меткой, указанной в этом операторе. Правда, в случае расширения речь идет скорее об 
					операторе условного перехода &mdash; когда исходный прецедент (а именно, последовательность 
					действий, содержащаяся в нем) приходит в точку расширения, происходит оценка условий расширения. 
					Если условия выполняются, прецедент включает в себя последовательность действий из расширяющего 
					прецедента.
				</p>
				<p>
					Точка расширения описывается в дополнительном разделе прецедента, отделенном от его названия 
					горизонтальной линией &mdash; точно так же, как в отдельных разделах перечисляются атрибуты 
					класса и его операции. Ниже показан пример описания точки расширения, позаимствованный нами из 
					Zicom Mentor (рис. 6.12).
				</p>
				<figure>
					<img src="index_use_case_diagram/06_12_uml.gif" alt="picture is missing" title="Точка расширения на диаграмме прецедентов">
						<figcaption>Рисунок 6.12</figcaption>
				</figure>
				<p>
					В этом примере регистрация пассажиров авиарейса включает в себя контроль службы безопасности, а 
					при условии (указанном в примечании после служебного слова <q>Condition:</q>), что человек часто 
					летает и салон переполнен (обратите внимание на оператор <em>AND</em>, говорящий об 
					одновременности выполнения условий), класс билета может быть повышен, например, с <q>эконом</q> 
					до <q>бизнес-класса</q>. Причем такой апгрейд может произойти только после того, как билет 
					предъявлен на стойку регистрации &mdash; это и есть точка расширения. Она описана (ее имя 
					указано) в дополнительном разделе прецедента после служебной фразы <q>Extension points:</q>. 
					Предваряя вопрос читателя, скажем, что прецедент может иметь сколь угодно много точек расширения. 
					А сопоставить конкретный расширяющий прецедент с определенной точкой расширения можно, прочитав 
					условия расширения, указанные в комментариях, &mdash; само условие записывается после служебного 
					слова <q>Condition:</q> в фигурных скобках, за которыми идет служебная фраза 
					<q>Extension point:</q>, и после нее указывается имя точки расширения. Посмотрите еще раз на 
					наш пример с регистрацией пассажиров в аэропорту и убедитесь сами, что все это очень просто!
				</p>
				<p>
					Некоторое недоумение может вызвать то, что стрелка направлена всегда в сторону расширяемого 
					прецедента. Но и это легко объяснить с точки зрения нашего тезиса, что <q>стрелка всегда 
					указывает на того, от которого что-то требуют</q>: ведь для того, чтобы прецедент был расширен, 
					нужно, чтобы он попал в точку расширения и проверилась истинность условий &mdash; только тогда 
					действия, содержащиеся в расширяющем прецеденте, смогут быть добавлены в последовательность 
					действий исходного прецедента. Так что все правильно &mdash; от расширяемого прецедента 
					требуется точка расширения и проверка условий, потому и стрелка направлена к нему.
				</p>
				<p>
					Подытоживая все вышесказанное, можно сказать, что расширение позволяет моделировать 
					необязательное поведение системы (был бы класс билета повышен, если бы пассажир не налетал 
					нужного количества миль, а салон был бы почти пуст?). Сам факт расширения зависит от выполнения 
					условий &mdash; расширения ведь может и не произойти! Это просто отдельные последовательности 
					действий, выполняемые лишь при определенных обстоятельствах и включаемые в определенных точках 
					сценария (обычно в результате явного взаимодействия с эктором).
				</p>
				<p>
					Организация прецедентов с помощью выделения общего поведения (включение) и различных вариантов 
					поведения (расширение) &mdash; важная составляющая часть процесса разработки простого, 
					сбалансированного и понятного набора прецедентов. Можно сказать даже, что использование 
					включения и расширения &mdash; признак хорошего стиля в моделировании прецедентов.
				</p>
				<p>
					На этом разговор о нотации диаграмм прецедентов можно было бы и завершить. Хотелось бы только 
					сказать еще пару слов о соотношении между понятиями прецедента и кооперации. О кооперации мы уже 
					говорили ранее (помните диаграммы взаимодействия?) как о множестве ролей, работающих вместе, 
					чтобы обеспечить некоторое поведение системы. Мы также упоминали о том, что прецеденты отвечают 
					на вопрос <q>что делает система?</q>, но не говорят, как именно она это делает. На этапе анализа 
					понимать, как именно система реализует свое поведение, действительно не нужно. Но при переходе к 
					реализации неплохо бы знать, какие именно классы (или другие элементы модели), совместно работая, 
					обеспечивают нужное поведение. То есть мы логично перешли от разговора о прецедентах к разговору 
					о <em>кооперации</em>! Недаром обозначения кооперации и прецедента очень похожи (читатель, 
					конечно, помнит, что кооперация обозначается пунктирным эллипсом) (рис. 6.13).
				</p>
				<figure>
					<img src="index_use_case_diagram/06_13_uml.gif" alt="picture is missing" title="Кооперация на диаграмме прецедентов">
						<figcaption>Рисунок 6.13</figcaption>
				</figure>
				<p>
					Так в каком же отношении находятся прецедент и кооперация? Из предыдущего абзаца логично следует, 
					что это отношение реализации. Каждый прецедент реализуется одной или несколькими кооперациями. 
					Это, конечно, не означает, что классы жестко распределены по кооперациям: классы, принимающие 
					участие в кооперации, реализующей определенный прецедент, будут участвовать и в других 
					кооперациях.
				</p>
			</section>
			<section>
				<h3>Моделирование при помощи диаграмм прецедентов</h3>
				<p>
					Модель прецедентов, по сути, является концептуальной моделью системы. В ней, как мы уже не раз 
					отмечали, в общих чертах описывается только поведение (функциональность) системы, а о деталях 
					реализации речь не идет &mdash; на данном этапе реализация не важна, гораздо важнее собрать 
					требования к системе и оформить их в наглядном виде, понятном и разработчикам, и заказчику.
				</p>
				<p>
					Итак, подводя итоги, мы можем сформулировать три причины использования прецедентов. Или, вернее, 
					три способа использования прецедентов (не случайно в русском переводе частенько можно встретить 
					словосочетание <q>вариант использования</q>!) в ходе работы над системой:
				</p>
				<ul>
					<li>
						Прецеденты дают возможность аналитикам, пользователям и разработчикам говорить на одном 
						языке: используя прецеденты, аналитики (эксперты в предметной области) могут на основе 
						пожеланий заказчика описать поведение системы с точки зрения пользователя с такой степенью 
						детализации, что разработчики смогут без труда сконструировать <q>внутренности</q> системы. 
						В то же время, нотация диаграмм прецедентов настолько проста, что даже неподготовленный 
						пользователь (заказчик) способен понять их смысл и помочь в их уточнении &mdash; ведь 
						картинки (а тем более комиксы, каковыми, по сути, являются диаграммы UML) воспринимаются 
						намного легче, чем текст!
					</li>
					<li>
						Прецеденты позволяют разработчикам понять назначение элемента: система, подсистема или даже 
						класс могут быть сложными образованиями, состоящими из большого числа составных частей и 
						имеющими большое число атрибутов и операций. Моделирование прецедентов позволяет лучше 
						представить себе поведение системы, понять, какие элементы модели играют какие роли в 
						реализации этого поведения, в какие кооперации входят, и какой именно прецедент (функционал 
						системы) реализуют.
					</li>
					<li>
						Прецеденты являются основой для тестирования элемента в течение всей разработки: модель 
						прецедентов описывает желаемое поведение системы (ее функционал) с точки зрения пользователя. 
						Так что, постоянно сопоставляя предоставляемый элементом (фактический) функционал с 
						имеющимися прецедентами, можно надежно контролировать корректность реализации элемента. Вот 
						вам и надежный источник регрессионных тестов. Кроме этого, появление нового прецедента 
						зачастую заставляет пересмотреть реализацию элемента, дабы убедиться, что она обладает 
						достаточной гибкостью, изменяемостью и масштабируемостью.
					</li>
					</ul>
					<p>
						Прецеденты полезны и для прямого, и для обратного проектирования. При прямом проектировании 
						мы, по сути, осуществляем <q>перевод</q> с UML на некий язык программирования. И тестировать 
						созданное приложение следует, основываясь именно на потоках событий, описываемых 
						прецедентами. Обратное проектирование предполагает перевод с языка программирования на язык 
						UML-диаграмм. Такими вещами приходится заниматься в силу ряда причин:
					</p>
					<ul>
					<li>
						С целью <strong>поиска ошибок</strong> и чтобы убедиться в адекватности дизайна. Отличная идея после первого 
						перевода с UML на язык программирования сделать обратный перевод и сравнить исходные и 
						восстановленные UML-модели (желательно, чтобы эти переводы выполнялись разными командами). 
						Это позволит убедиться в том, что дизайн системы соответствует модели, никакая информация в 
						ходе перевода не была утеряна, да и попросту выловить некоторые <q>баги</q>. Такой подход 
						называется обратной семантической трассировкой 
						&mdash; <abbr title="Reverse Semantic Traceability">RST</abbr> и разрабатывается компанией 
						<a href="http://www.intspei.com" title="www.intspei.com" target="_blank">INTSPEI</a> как 
						одна из базовых техник методологии INTSPEI 
						<a href="https://en.wikipedia.org/wiki/P-Modeling_Framework" title="wikipedia" target="_blank">P-Modeling Framework</a>, 
						краткие сведения о которой вы можете найти в приложении к этому курсу.</li>
					<li>
						И наконец, следует отметить, что, конечно, только диаграмм прецедентов, как и сценариев, ими 
						определяемых, недостаточно, чтобы создать модель поведения системы. Как мы уже не раз 
						упоминали, прецеденты говорят, что делает система, но не говорят, как. Об этом говорят 
						сценарии, но в текстовой форме, что делает их довольно сложными для восприятия. На помощь 
						приходят диаграммы взаимодействий, которые <strong>визуализируют сценарии</strong>. Таким 
						образом, мы теперь можем дополнить нашу старую <q>псевдодиаграмму</q> и на этом успокоиться 
						(рис. 6.14):
					</li>
				</ul>
				<figure>
					<img src="index_use_case_diagram/06_14_uml.gif" alt="picture is missing" title="Пример визуализации сценария с помощью диаграммы прецедентов">
					<figcaption>Рисунок 6.14</figcaption>
				</figure>
				<p>
					В заключение приведем пару примеров законченных диаграмм прецедентов. Первый пример (смысл 
					которого понятен и без дополнительных пояснений) демонстрирует включение, расширение и 
					наследование прецедентов. Обратите внимание на стрелки, которые направлены к экторам, 
					изображающим шлюзы. Все правильно &mdash; ведь система пользуется их услугами при отправке 
					сообщений, в то время как маркетолог, наоборот, пользуется услугами системы, и потому стрелки 
					направлены от него (рис. 6.15).
				</p>
				<figure>
					<img src="index_use_case_diagram/06_15_uml.gif" alt="picture is missing" title="Пример диаграммы прецедентов">
					<figcaption>Рисунок 6.15</figcaption>
				</figure>
				<p>
					Первая диаграмма, неплохо оформленная, говорит нам о том, что утки очень не любят платить 
					за пиво, предпочитая пить в долг (рис. 6.16).
				</p>
				<figure>
					<img src="index_use_case_diagram/06_16_uml.gif" alt="picture is missing" title="Пример диаграммы прецедентов">
					<figcaption>Рисунок 6.16</figcaption>
				</figure>
				<p>
					Кстати, обратите внимание на рамки диаграммы, показанные на этом примере, &mdash; прямоугольник, 
					отделяющий область содержимого диаграммы и имеющий в верхней части специальный раздел для ее 
					имени.
				</p>
				<p>
					Следующая картинка, которая не является хорошим примером диаграммы прецедентов, но просто 
					забавна. Это рассказ о способах поведения, позволяющих гарантированно (!) провалить любой 
					экзамен (рис. 6.17):
				</p>
				<figure>
					<img src="index_use_case_diagram/06_17_uml.gif" alt="picture is missing" title="Пример диаграммы прецедентов">
					<figcaption>Рисунок 6.17</figcaption>
				</figure>
			</section>
			<section>
				<h3>Выводы</h3>
				<ul>
					<li>Модель прецедентов позволяет описать систему на концептуальном уровне.</li>
					<li>
						Диаграммы прецедентов &mdash; отличное средство коммуникаций между экспертами, 
						пользователями и разработчиками, а также основа для тестирования создаваемой системы.
					</li>
					<li>
						Прецедент &mdash; это описание набора последовательных событий (включая возможные варианты), 
						выполняемых системой, которые приводят к наблюдаемому эктором результату.
					</li>
					<li>
						Эктор &mdash; это набор ролей, которые исполняет пользователь в ходе взаимодействия с 
						некоторой сущностью.
					</li>
					<li>
						Прецеденты (как и экторы) могут быть генерализованы, т. е. наследовать и дополнять свойства 
						своих предков.
					</li>
					<li>
						Прецеденты также могут вступать между собой в отношения включения и расширения, что 
						позволяет разложить прецеденты на более простые составляющие и выделить необязательное 
						поведение.
					</li>
					<li>
						Каждый прецедент реализуется одной или несколькими кооперациями.
					</li>
					<li>
						Сценарии специфицируют прецеденты, а диаграммы взаимодействий визуализируют сценарии.
					</li>
				</ul>
			</section>
		</div>
		
		<footer role="contentinfo">
			<hr/>
			<p>Оформление страницы <a href="http://www.sobolandrey.by"  target="_blank" title="Перейти на веб-сайт">SAY</a></p>
			<p>&copy; 2015</p>
		</footer>
		
		<aside role="complementary">
			<nav role="navigation">
				<ul>
					<li class='aside_pointer'> <span id="span_aside">навигация</span></li>
						<ul>
							<li class='main_page'>Для перехода на <br> <a href='index.html'>стартовую</a> страницу</li>
						</ul>
					<li class='aside_pointer'> <span>содержание</span></li>
						<ul>
							<li class='high_nav'><a href='index_what_is_uml.html'>Что такое UML</a></li>
							<li class='high_nav'><a href='index_kinds_of_diagrams.html'>Виды диаграмм</a></li>
							<li class='high_nav'><a href='index_class_diagram.html'>Диаграмма классов</a></li>
							<li class='high_nav'><a href='index_activity_diagrams.html'>Диаграммы активностей</a></li>
							<li class='high_nav'><a href='index_interaction_diagrams.html'>Диаграммы взаимодействия</a></li>
							<li class='high_nav'><a href='index_use_case_diagram.html'>Диаграммы прецедентов</a></li>
							<li class='high_nav'><a href='index_case_tools.html'>Обзор CASE-средств для построения диаграмм UML</a></li>
						</ul>
					<li class='aside_pointer'><span>полезное</span></li>
						<ul>
							<li class='low_nav'><a href='http://www.intuit.ru/' target='_blank'>НОУ «ИНТУИТ»</a></li>
							<li class='low_nav'><a href='http://www.omg.org/' target='_blank'>Object Managment Group</a></li>
							<li class='low_nav'><a href='http://www.sparxsystems.com.au/' target='_blank'>Словарь-ассистент UML 2.0	</a></li>
						</ul>
				</ul>
			</nav>
			<div id="extra2" role="presentation"></div>
			<div id="extra3" role="presentation"></div>
		</aside>
		<div id="top"> <i class="fa fa-angle-double-up"></i> </div>
	</div>
		
	<div id="extra1" role="presentation"></div>
	<div id="extra4" role="presentation"></div>
	
	<!--[if lt IE 9]>
	<script src="libs/html5shiv/es5-shim.min.js"></script>
	<script src="libs/html5shiv/html5shiv.min.js"></script>
	<script src="libs/html5shiv/html5shiv-printshiv.min.js"></script>
	<script src="libs/respond/respond.min.js"></script>
	<![endif]-->
	<script src="libs/jquery/jquery-1.11.1.min.js"></script>
	<script src="js/common.js"></script>
	<!-- Yandex.Metrika counter --><!-- /Yandex.Metrika counter -->
	<!-- Google Analytics counter --><!-- /Google Analytics counter -->
</body>
</html>