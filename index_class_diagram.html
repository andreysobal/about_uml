<!DOCTYPE html>
<!--[if lt IE 7]><html lang="ru" class="lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html lang="ru" class="lt-ie9 lt-ie8"><![endif]-->
<!--[if IE 8]><html lang="ru" class="lt-ie9"><![endif]-->
<!--[if gt IE 8]><!-->
<html lang="ru">
<!--<![endif]-->
<head>
	<meta charset="utf-8" />
	<title>Диаграмма классов</title>
	<meta name="description" content="" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<link rel="shortcut icon" href="favicon.ico" />
	<link rel="stylesheet" href="libs/font-awesome-4.2.0/css/font-awesome.min.css" />
	<link rel="stylesheet" href="fonts.css" />
	<link rel="stylesheet" href="main.css" />
	<link rel="stylesheet" href="media.css" />
</head>
<body>
	<div id="page-wrapper">
		<header role="banner">
			<a href='index.html'>
				<h1>Unified Modeling Language<br/>UMLВВЕДЕНИЕ</h1>
				<hr class="left"> 
				<hr class="right">
			</a>
			<div class="quotes">UML &mdash; унифицированный язык моделирования, который является графическим языком для спецификации, визуализации, проектирования и документирования систем.</div>
		</header>
		
		<div class="main" role="main">
			<section>
				<h3>Как класс изображается на диаграмме UML?</h3>
				<p>
					Архитектор программного обеспечения в первую очередь обращает внимание на объекты 
					предметной области. Программист же концентрируется на поведении этих объектов, 
					пользуясь классами, к которым они принадлежат. Вот поэтому-то диаграмма классов и 
					является одной из важнейших диаграмм UML. Она используется для документирования 
					программных систем, и основным ее компонентом является класс. Что такое класс, мы 
					уже говорили ранее, когда знакомились с видами диаграмм UML. В предыдущей лекции 
					мы рассматривали назначение диаграммы классов, знакомились с примерами готовых 
					диаграмм, но не вникали в тонкости обозначений, используемых на диаграмме. В тех 
					примерах все казалось нам очень понятным и логичным. Тем не менее, некоторые 
					нюансы все же следует рассмотреть, и как раз этим мы сейчас и займемся.
				</p>
				<p>
					Класс на диаграмме изображается в виде прямоугольника, разделенного горизонтальными 
					линиями на три части. В первой части указывается название класса. Как правило, имя 
					класса состоит из одного, максимум двух слов. Вторая часть содержит перечень 
					атрибутов класса, которые характеризуют тот или иной объект этого класса в модели 
					предметной области. Третья часть содержит перечень операций, отражающих его 
					поведение в модели предметной области (рис. 3.1). Все очень просто, не так ли?
				</p>
				<figure>
					<img src='index_class_diagram/03_01_uml.gif' alt='picture is missing' title='Пример диаграммы классов' width='322' height='139'/>
					<figcaption>Рисунок 3.1</figcaption>
				</figure>
			</section>
			<section>
				<h3>А что внутри?</h3>
				<p>
					Мы узнали, как класс изображается и выглядит <q>снаружи</q>. А что же внутри 
					объектов класса? Пользователю об этом знать необязательно, более того, абсолютно не 
					нужно. Для человека, использующего его, объект выступает в роли черного ящика. 
					Скрывая от пользователя внутреннее устройство объекта, мы обеспечиваем его надежную 
					работу. Сейчас мы рассмотрим, как убрать из поля зрения пользователя то, что ему 
					знать не нужно.
				</p>
				<p>
					Читателя может слегка смутить слово <q>пользователь</q>, которым мы злоупотребляли в 
					предыдущем абзаце. Зачем вообще пользователю какие-то объекты и классы? Внесем 
					ясность. Программист, использующий в своей программе созданные кем-то компоненты, 
					как раз и выступает в роли такого пользователя. Зачем ему знать что внутри &mdash; 
					он знает, какие атрибуты надо модифицировать и какие операции использовать, чтобы 
					заставить объект работать именно так, как ему нужно! Более того, а многие ли из 
					нас знают, как именно устроен и по каким принципам работает, например, телевизор 
					&mdash; объект класса <q>Бытовой прибор</q>?
				</p>
				<p>
					Сокрытие от пользователя внутреннего устройства объектов называется инкапсуляцией. 
					Если говорить более <q>научным</q> языком, то 
					<a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" title="Wikipedia" target="_blank">инкапсуляция</a> 
					&mdash; это защита отдельных элементов объекта, не затрагивающих существенных 
					характеристик его как целого. Инкапсуляция нужна не только для того, чтобы создать 
					иллюзию простоты объекта для пользователя (по словам Г. Буча). Но вернемся к примеру 
					с телевизором. Нам этот прибор кажется очень простым только потому, что при работе с 
					ним мы используем простой и понятный <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81" target="_blank" title="Wikipedia">интерфейс</a> 
					&mdash; пульт дистанционного управления. Мы знаем: для того чтобы увеличить громкость 
					звука, надо нажать вот эту кнопку, а чтобы переключить канал &mdash; вот эту. Как 
					телевизор устроен внутри, мы не знаем. Более того &mdash; в отсутствие пульта ДУ 
					такое знание было бы неудобным для нас и весьма опасным для самого телевизора, вздумай 
					мы увеличить громкость с помощью паяльника. Поэтому-то пульт ДУ и защищает от нас 
					<q>внутренности</q> телевизора! Вот так инкапсуляция реализуется в реальном мире.
				</p>
				<p>
					В программировании инкапсуляция обеспечивается немного по-другому &mdash; с помощью т. н. 
					модификаторов видимости. С их помощью можно ограничить доступ к атрибутам и операциям 
					объекта со стороны других объектов. Звучит это немного пугающе, но на самом деле все 
					просто. Если атрибут или операция описаны с модификатором <em>private</em>, то доступ к 
					ним можно получить только из операции, определенной в том же классе. Если же атрибут или 
					операция описаны с модификатором видимости <em>public</em>, то к ним можно получить доступ 
					из любой части программы. Модификатор protected разрешает доступ только из операций этого 
					же класса и классов, создаваемых на его основе. В языках программирования могут встречаться 
					модификаторы видимости, ограничивающие доступ на более высоком уровне, например, к 
					классам или их группам, однако смысл инкапсуляции от этого не изменяется. В UML атрибуты 
					и операции с модификаторами доступа обозначаются специальными символами слева от их имен:
				</p>
				<ul class="other_list">
					<li> <q>+</q> &mdash; открытый доступ (<em>public</em>)</li>
					<li><q>-</q> &mdash; только из операций того же класса (<em>private</em>)</li>
					<li><q>#</q> &mdash; только из операций этого же класса и классов, создаваемых на его 
					основе (<em>protected</em>)</li>
				</ul>
				<p>
					Рассмотренный ранее пример с телевизором средствами UML (конечно же, это очень высокоуровневая 
					абстракция) можно изобразить так (рис. 3.2):
				</p>
				<figure>
					<img src="index_class_diagram/03_02_uml.gif" alt='picture is missing' title='Телевизор на диаграмму классов' width='225' height='209'/>
					<figcaption>Рисунок 3.2</figcaption>
				</figure>
				<p>
					Не правда ли, все понятно и предельно просто? Зачем, например, пользователю знать числовые 
					значения частот каналов? Он знает, что достаточно запустить процедуру автоматического поиска 
					каналов и телевизор все сделает за него. Вот вам и инкапсуляция &mdash; оказывается, она 
					повсюду вокруг нас. Оглянитесь и подумайте, сколько вещей вокруг имеют скрытые свойства и 
					выполняют скрытые операции. Испугались? Вот то-то же!
				</p>
			</section>
			<section>
				<h3>Как использовать объекты класса?</h3>
				<p>
					Итак, мы рассмотрели инкапсуляцию &mdash; одно из средств защиты объектов. Все вроде бы 
					понятно, но как же именно работать с объектом?
				</p>
				<p>
					Если уж говорить о защите объекта, то чтобы она действительно была эффективной, надо 
					позаботиться о некоем стандартном и безопасном, не зависящим от языка программирования 
					способе доступа к объекту. К тому же такой стандартный способ доступа должен быть простым 
					и с точки зрения использования, и с точки зрения реализации. Вспомните пример с 
					телевизором. Нажимая кнопки на пульте, мы ожидаем, что телевизор откликнется на это 
					действие каким-то определенным образом &mdash; именно так, как мы ожидаем, а не иначе. 
					То есть, с одной стороны, пульт ДУ является средством доступа к скрытым операциям, 
					выполняемым телевизором, а с другой стороны &mdash; пульт обеспечивает нужное для нас 
					поведение телевизора. В данном примере именно пульт является таким стандартным средством 
					доступа к телевизору. Можно даже сказать, средством доступа, не зависящим от конкретной 
					модели телевизора &mdash; вспомните об универсальных пультах и о том, как отключаете звук 
					надоедливой рекламы на экране в вагоне поезда, используя КПК!
				</p>
				<p>
					В том же примере с телевизором у нас впервые промелькнуло слово <q>интерфейс</q>. И не 
					случайно промелькнуло: именно так называют тот самый стандартный способ доступа к объекту. 
					Более строго, интерфейс &mdash; это логическая группа открытых ( <em>public</em> ) операций 
					объекта. Один и тот же объект может иметь несколько интерфейсов. У телевизора, например, их 
					два &mdash; пульт ДУ и кнопки на корпусе. А может и больше &mdash; вспомните о возможности 
					управлять бытовой техникой с помощью КПК или универсального пульта ДУ.
				</p>
				<p>
					Кстати, посмотрите внимательнее на пульт ДУ или на экран программы удаленного контроля. Что 
					вы видите &mdash; кнопки? Или кнопки, сгруппированные по функциональному признаку? Да, именно 
					так: кнопки, переключающие каналы, расположены отдельно, рядом &mdash; группа кнопок, 
					отвечающих за регулировку громкости звука, рядом &mdash; группа программируемых кнопок, и т. д. 
					В принципе, можно сказать, что пульт реализует не один, а несколько интерфейсов &mdash; по 
					числу <em>функциональных групп кнопок</em>. Впрочем, это уже формализм: мы просто хотели 
					проиллюстрировать слова <q>логическая группа</q> в определении интерфейса.
				</p>
				<p>
					Однако интерфейс &mdash; это не только и не столько группа операций объекта. <em>Интерфейс 
					отражает внешние проявления объекта, показывает, каким образом осуществляется взаимодействие 
					с ним, скрывая остальные детали, не имеющие отношения к процессу взаимодействия</em>.
				</p>
				<p>
					Интерфейс всегда реализуется некоторым классом, который в таком случае называют <em>классом, 
					поддерживающим интерфейс</em>. Как мы уже говорили ранее, один и тот же объект может иметь 
					несколько интерфейсов. Это означает, что класс этого объекта реализует все операции этих 
					интерфейсов. К данному моменту в голове читателя может созреть вопрос: <q>Мы же, вроде бы, 
					говорили о классах и объектах, а теперь вдруг перешли на интерфейсы. Да и вообще, используются 
					ли они в практике программирования или являются просто изящной теоретической конструкцией?</q>. 
					Ответ на этот вопрос прост: многие из существующих технологий программирования (например, 
					<a href="https://ru.wikipedia.org/wiki/CORBA" title="Common Object Request Broker Architecture" target="_blank">CORBA</a>, 
					<a href="https://ru.wikipedia.org/wiki/Component_Object_Model" title="Component Object Model" target="_blank">COM</a>, 
					<a href="https://ru.wikipedia.org/wiki/JavaBeans" title="Wikipedia" target="_blank">Java Beans</a>) 
					не только активно используют механизм интерфейсов, но и, по сути, полностью основаны на нем.
				</p>
				<p>
					Что ж, наверное, пришло время поговорить о том, как интерфейс изображается на диаграммах. 
					Изображаться он может несколькими способами. Первый и самый простой из них &mdash; это класс со 
					<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D1%80%D0%B5%D0%BE%D1%82%D0%B8%D0%BF_(UML)" title="Wikipedia" target="_blank">стереотипом</a>
					<q>interface</q> (рис. 3.3):
				</p>
				<figure>
					<img src="index_class_diagram/03_03_uml.gif" alt="picture is missing" title="Интерфейс на диаграмме классов" width="167" height="124"/>
					<figcaption>Рисунок 3.3</figcaption>
				</figure>
				<p>
					Этот способ хорош, если нужно показать, какие именно операции предоставляет интерфейс. Если же такие 
					подробности в данный момент не важны, предоставляемый интерфейс изображают в виде кружочка или, как 
					говорят, <q>леденца</q> (lollipop) (рис. 3.4):
				</p>
				<figure>
					<img src="index_class_diagram/03_04_uml.gif" alt="picture is missing" title="Упрощенное отображение интерфейса на диаграмме классов" width="187" height="59"/>
					<figcaption>Рисунок 3.4</figcaption>
				</figure>
				<p>
					Обратите внимание на маленький значок на закладке папки ConduitSet. Это обозначение подсистемы, 
					мы могли бы не рисовать его, а просто использовать стереотип <q>subsystem</q>. Впрочем, об этом 
					мы еще поговорим.
				</p>
				<p>
					И наконец, еще один способ изображения интерфейса. Он не является альтернативой описанным ранее 
					способам, а используется для изображения интерфейсов, требующихся объекту для выполнения его 
					работы. Обозначается он очень простым и логичным символом. Впрочем, судите сами (рис. 3.5):
				</p>
				<figure>
					<img src="index_class_diagram/03_05_uml.gif" alt="picture is missing" title="Упрощенное отображение интерфейса на диаграмме классов" width="156" height="47"/>
					<figcaption>Рисунок 3.5</figcaption>
				</figure>
				<p>
					Наблюдательный читатель уже, наверное, заметил, как логически совмещаются символы 
					предоставляемого и требуемого интерфейсов.
				</p>
				<p>
					Действительно, на диаграммах довольно часто можно увидеть такую картинку (рис. 3.6):
				</p>
				<figure>
					<img src="index_class_diagram/03_06_uml.gif" alt="picture is missing" title="Упрощенное отображение интерфейса на диаграмме классов" width="90" height="28"/>
					<figcaption>Рисунок 3.6</figcaption>
				</figure>
				<p>
					Да, кстати, вы заметили, что названия интерфейсов начинаются с буквы I? Эта традиция пошла из 
					языка Java, и, как показывает практика, она весьма облегчает жизнь, если нужно, например, 
					быстро разобраться в сложной диаграмме, составленной другим человеком.
				</p>
			</section>
			<section>
				<h3>Всегда ли нужно создавать новые классы?</h3>
				<p>
					Начнем с вопроса, казалось бы, не имеющего никакого отношения к рассматриваемому вопросу, а 
					именно &mdash; всегда ли нужно создавать новый класс для каждой новой задачи? Правильный ответ, 
					конечно же, <q>нет</q>. Это было бы странно и неэффективно. <q>Фишка</q> состоит в том, что мы 
					можем использовать уже существующие классы, адаптируя их функциональность для выполнения новых 
					задач. Таким образом появляется возможность не создавать систему классов с нуля, а задействовать 
					уже имеющиеся решения, которые были созданы ранее, при работе над предыдущими проектами. Впрочем, 
					наше высказывание о странности и неэффективности создания новых классов не является истиной в 
					последней инстанции. Могут быть ситуации, когда существующие классы по каким-либо причинам не 
					устраивают архитектора, и тогда требуется создать новый класс. Следует, однако, избегать ситуаций, 
					когда созданный класс (а точнее, его набор операций и атрибутов) практически повторяет 
					существующий, лишь незначительно отличаясь от него. Все-таки лучше не изобретать велосипед и 
					стараться создавать классы на основе уже существующих, и только если подходящих классов не нашлось 
					&mdash; создавать свои, которые, в свою очередь, могут (и должны!) служить основой для других 
					классов. Мы уже не говорим о том, что создание классов предполагает значительный объем усилий по 
					кодированию и тестированию. В общем случае, сказанное выше можно проиллюстрировать такой 
					диаграммой (рис. 3.7):
				</p>
				<figure>
					<img src="index_class_diagram/03_07_uml.gif" alt="picture is missing" title="Советы по проектированию классов" width="444" height="232">
					<figcaption>Рисунок 3.7</figcaption>
				</figure>
				<p>
					В дополнение можно назвать несколько причин, почему стоит использовать уже существующие классы:
				</p>
				<p>
					Во-первых, идя этим путем, мы <em>пользуемся плодами ранее принятых решений</em>. Действительно, 
					если когда-то мы уже решили некоторую проблему, зачем начинать все <q>с нуля</q>, повторяя уже 
					однажды проделанные действия?
				</p>
				<p>
					Во-вторых, таким образом мы <em>делаем решение мобильным и расширяемым</em>. Используя уже 
					существующие классы и создавая на их основе новые, мы можем развивать решение практически 
					неограниченно, добавляя лишь необходимые нам в данный момент детали &mdash; атрибуты и операции.
				</p>
				<p>
					В-третьих, <em>существующие классы, как правило, хорошо отлажены и показали себя в работе</em>. 
					Разработчику не надо тратить время на кодирование, отладку, тестирование и т. д., &mdash; мы 
					работаем с хорошо отлаженным и проверенным временем кодом, который зарекомендовал себя в других 
					проектах и в котором уже выявлено и исправлено большинство ошибок.
				</p>
				<p>
					А теперь внимание &mdash; мы много говорили о том, что нужно создавать классы на основе уже 
					существующих, но так и не сказали ни слова о том, как это сделать. Пришло время внести ясность 
					в этот вопрос. Тем самым мы подбираемся к понятию <em>обобщения</em> или <em>генерализации</em>, 
					которое играет очень важную роль в <abbr title="Объектно-ориентированное программирование">ООП</abbr>, 
					являясь одним из его базовых принципов. Обобщение &mdash; это отношение между более общей 
					сущностью, называемой суперклассом, и ее конкретным воплощением, называемым подклассом. Иногда 
					обобщение называют отношениями типа <q>является</q>, имея в виду, что одни сущности (например, 
					круг, квадрат, треугольник) являются воплощением более общей сущности (например, класса 
					<q>геометрическая фигура</q>). При этом все атрибуты и операции суперкласса независимо от 
					модификаторов видимости входят в состав подкласса.
				</p>
				<p>
					Обобщение (или, как часто говорят, <em>наследование</em>) на диаграммах обозначается очень 
					просто &mdash; незакрашенной треугольной стрелкой, направленной на суперкласс (рис. 3.8).
				</p>
				<figure>
					<img src="index_class_diagram/03_08_uml.gif" alt="picture is missing" title="Наследование на диаграмме классов" width="395" height="224">
					<figcaption>Рисунок 3.8</figcaption>
				</figure>
				<p>
					Для того чтобы научиться эффективно моделировать наследование, обратимся к классикам, а именно к 
					Г. Бучу. Он советует проводить эту процедуру в такой последовательности:
				</p>
				<ol>
					<li>Найдите атрибуты, операции и обязанности, общие для двух или более классов из данной совокупности. 
					Это позволит избежать ненужного дублирования структуры и функциональности объектов.</li>
					<li>Вынесите эти элементы в некоторый общий суперкласс, а если такого не существует, то создайте 
					новый класс.</li>
					<li>Отметьте в модели, что подклассы наследуются от суперкласса, установив между ними отношение 
					обобщения.</li>
				</ol>
				<p>
					А вот и пример применения этого подхода (рис. 3.9):
				</p>
				<figure>
					<img src="index_class_diagram/03_09_uml.gif" alt="picture is missing" title="Пример применения подхода Г. Буча к эффективному моделированию наследования" width="352" height="173">
					<figcaption>Рисунок 3.9</figcaption>
				</figure>
				<p>
					На первый взгляд, кажется странным, что класс <q>точка</q> не имеет никаких атрибутов, а круг 
					имеет только радиус. С прямоугольником, вроде бы, все понятно &mdash; ширина и высота, но вот 
					только где он расположен в пространстве, этот прямоугольник? Давайте попробуем следовать 
					советам Буча. Итак, положение всех трех фигур можно однозначно определить с помощью пары чисел. 
					Для точки &mdash; это вообще единственные ее характеристики, для круга и прямоугольника &mdash; 
					их центры (под центром прямоугольника мы понимаем точку пересечения его диагоналей). Вот они, 
					общие атрибуты! Таким образом, мы создали суперкласс <q>Фигура</q>, имеющий два атрибута &mdash; 
					координаты центра. Все остальные классы на этой диаграмме связаны с классом <q>Фигура</q> 
					отношением обобщения, т. е. в них нужно доопределить только <q>недостающие</q> атрибуты &mdash; 
					радиус, ширину и высоту. Атрибуты, описывающие координаты центра, эти классы имеют изначально 
					как потомки класса <q>Фигура</q> &mdash; они их наследуют. Заметим, что операции классов мы тут 
					не рассматриваем: понятно, что с ними была бы та же история.
				</p>
				<p>
					Так, с наследованием вроде бы разобрались. Пришло время для маленькой провокации с нашей 
					стороны. Классы-потомки ведь наследуют атрибуты и операции суперкласса? Таким образом, они 
					могут наследовать и их интерфейсы &mdash; то есть <em>объекты абсолютно разной природы могут 
					иметь один и тот же интерфейс</em>! Так как же тогда определить, какого же все-таки класса объект? 
					Да и нужно ли это вообще?
				</p>
				<p>
					Действительно, объекты разной природы (или говоря проще, разных классов) могут поддерживать 
					один и тот же интерфейс именно так, как того ожидает пользователь. Примером тому может служить 
					рассмотренная выше диаграмма с геометрическими фигурами. Все рассмотренные фигуры имеют, 
					например, операцию рисования на экране. С точки зрения пользователя в каждом случае это одно 
					и то же действие. Однако реализованы эти операции по-разному &mdash; ведь процедура изображения 
					прямоугольника сильно отличается от подобной процедуры для круга. Но для пользователя это 
					неважно: ведь сигнатура-то одна и та же! А возможно это благодаря еще одному из основных 
					принципов <abbr title="Объектно-ориентированное программирование">ООП</abbr> - 
					<em>полиморфизму</em>. Как мы только что упомянули, работа механизма полиморфизма основана на 
					совпадении сигнатуры метода, объявленного в интерфейсе, и сигнатуры самого метода. Методы 
					внутри классов-потомков могут быть (и наверняка будут!) переопределены, их реализации будут 
					различными, а сигнатуры останутся неизменными. Таким образом (и в этом легко ощутить мощь 
					<abbr title="Объектно-ориентированное программирование">ООП</abbr>), выполняя одни и те же 
					операции, разные объекты могут вести себя по-разному.
				</p>
				<p>
					Полиморфизм является <em>основой для реализации механизма интерфейсов в языках 
					программирования</em>. Вот, кстати, и ответ на вопрос, какого класса объект: как только 
					пользователь обращается к некоторой операции через интерфейс, определяется фактический класс 
					объекта и вызывается соответствующая операция класса. Примеры полиморфизма можно увидеть в 
					самых обыденных вещах, которыми мы пользуемся в повседневной жизни. Оглянитесь вокруг &mdash; 
					мир построен по <abbr title="Объектно-ориентированное программирование">ООП</abbr>. Матрица 
					работает! Например, всем привычная кредитная карточка, является интерфейсом для доступа к 
					банковскому счету через банкомат (и не только), одинаково работает в любой стране, вот только 
					ведет себя чуть-чуть по-разному, т. к. банкомат выдает деньги в местной валюте. Согласны, 
					пример не очень корректный, но зато очень наглядный! Думаем, понаблюдав за окружающим миром, 
					читатель сам сможет привести массу примеров полиморфизма.
				</p>
				<p>
					<em>Инкапсуляция, наследование и полиморфизм</em>, с которыми мы только что познакомились, 
					являются теми самыми тремя китами, на которых держится 
					<abbr title="Объектно-ориентированное программирование">ООП</abbr>. Если вы поняли суть этих 
					базовых принципов и осознали их истинную мощь, вы прошли большую часть пути, ведущего к полному 
					овладению <abbr title="Объектно-ориентированное программирование">ООП</abbr> как наиболее 
					адекватной методикой описания (так и тянет сказать <q>проектирования</q>) окружающего нас мира.
				</p>
			</section>
			<section>
				<h3>Отношения между классами</h3>
				<p>
					Ни один из объектов окружающего нас мира не существует сам по себе. Птицы летают потому, 
					что есть воздух, на который опираются их крылья. Каждый из нас связан с массой других 
					людей разнообразными родственными, профессиональными и другими связями, предполагающими 
					различные типы отношений. Точно так же и классы связаны между собой. И чтобы в полной мере 
					овладеть <abbr title="Объектно-ориентированное программирование">ООП</abbr>, нам 
					необходимо понять суть этих отношений и научиться их идентифицировать.
				</p>
				<p>
					Мы сказали, что объекты находятся в определенных отношениях друг с другом. Один из типов 
					таких отношений &mdash; это <em>зависимость</em>. Думаем, суть такого отношения понятна 
					уже из его названия &mdash; зависимость возникает тогда, когда реализация класса одного 
					объекта зависит от спецификации операций класса другого объекта. И если изменится 
					спецификация операций этого класса, нам неминуемо придется вносить изменения и в зависимый 
					класс. Приведем простой пример, опять-таки взятый из нашей повседневности. Иногда к нам в 
					руки попадают видеофайлы, воспроизвести которые <q>с лету</q> не удается. Почему? 
					Правильно, потому что на компьютере не установлены соответствующие кодеки. То есть 
					операция <q>Воспроизведение</q>, реализуемая программой-медиаплеером, зависит от операции 
					<q>Декомпрессия</q>, реализуемой кодеком. Если спецификация операции <q>Декомпрессия</q> 
					изменится, придется менять код медиаплеера, иначе он просто не сможет работать с каким-то 
					кодеком и, в лучшем случае, завершит свою работу с ошибкой. А вот так зависимость между 
					классами изображается в UML (рис. 3.10):
				</p>
				<figure>
					<img src="index_class_diagram/03_10_uml.gif" alt="picture is missing" title="Зависимость между классами на диаграмме классов" width="441" height="195">
					<figcaption>Рисунок 3.10</figcaption>
				</figure>
				<p>
					Стоит отметить, что зависимости на диаграммах изображают далеко не всегда, а только в тех 
					случаях, когда их отображение является важным для понимания модели. Часто зависимости лишь 
					подразумеваются, т. к. логически следуют из природы классов.
				</p>
				<p>
					Другой вид отношений между объектами &mdash; это <em>ассоциация</em>. Это просто связь 
					между объектами, по которой можно между ними перемещаться. Ассоциация может иметь имя, 
					показывающее природу отношений между объектами, при этом в имени может указываться 
					направление чтения связи при помощи треугольного маркера. Однонаправленная ассоциация 
					может изображаться стрелкой. Проиллюстрируем сказанное примерами (рис. 3.11):
				</p>
				<figure>
					<img src="index_class_diagram/03_11_uml.gif" alt="picture is missing" title="Ассоциация между объектами на диаграмме классов" width="403" height="134">
					<figcaption>Рисунок 3.11</figcaption>
				</figure>
				<p>
					Кроме направления ассоциации, мы можем указать на диаграмме роли, которые каждый класс 
					играет в данном отношении, и кратность, то есть количество объектов, связанных отношением 
					(рис. 3.12):
				</p>
				<figure>
					<img src="index_class_diagram/03_12_uml.gif" alt="picture is missing" title="Роли объектов в ассоциация на диаграмме классов" width="395" height="134">
					<figcaption>Рисунок 3.12</figcaption>
				</figure>
				<p>
					И насчет ролей, и насчет кратности на этой диаграмме все понятно &mdash; человек может 
					вообще не работать, работать в одной или более компаниях, а вот компании в любом случае 
					нужен хотя бы один сотрудник. Кстати, о кратности. Ассоциация может объединять три и 
					более класса. В этом случае она называется <em>n-арной</em> и изображается ромбом на 
					пересечении линий, как показано на этой диаграмме, позаимствованной нами из Zicom Mentor 
					(рис. 3.13):
				</p>
				<figure>
					<img src="index_class_diagram/03_13_uml.gif" alt="picture is missing" title="Ассоциация на диаграмме классов" width="485" height="331">
					<figcaption>Рисунок 3.13</figcaption>
				</figure>
				<p>
					Ранее мы говорили, что ассоциация &mdash; это <q>просто связь</q> между объектами. На 
					самом деле, в реальности связи бывают <q>просто связями</q> крайне редко. Обычно при 
					ближайшем рассмотрении под ассоциацией понимается более сложное отношение между классами, 
					например, связь типа <q>часть-целое</q>. Такой вид ассоциации называется <em>ассоциацией с 
					агрегированием</em>. В этом случае один класс имеет более высокий статус (целое) и состоит из 
					низших по статусу классов (частей). При этом выделяют <em>простое</em> и <em>композитное</em> 
					агрегирование и говорят о собственно <em>агрегации</em> и <em>композиции</em>. Простая 
					агрегация предполагает, что части, отделенные от целого, могут продолжать свое существование 
					независимо от него. Под композитным же агрегированием понимается ситуация, когда целое 
					владеет своими частями и их время жизни соответствует времени жизни целого, т. е. независимо 
					от целого части существовать не могут. Примеры этих видов ассоциаций и их обозначений в UML 
					можно увидеть на следующей диаграмме (рис. 3.14).
				</p>
				<figure>
					<img src="index_class_diagram/03_14_uml.gif" alt="picture is missing" title="Пример агрегации и композиции на диаграмме классов" width="305" height="306">
					<figcaption>Рисунок 3.14</figcaption>
				</figure>
				<p>
					Примеры, как нам кажется, очень простые и понятные. Винчестер можно вынуть из компьютера и 
					установить в новый компьютер или в USB-карман, т. е. существование жесткого диска с 
					разборкой системного блока не заканчивается. А вот кнопки без окон обычно существовать не 
					могут &mdash; с закрытием окна кнопки также исчезают.
				</p>
				<p>
					И, наконец, еще одна важная вещь, касающаяся ассоциации. В отношении между двумя классами 
					сама ассоциация тоже может иметь свойства и, следовательно, тоже может быть представлена в 
					виде класса. Пример прост (рис. 3.15):
				</p>
				<figure>
					<img src="index_class_diagram/03_15_uml.gif" alt="picture is missing" title="Свойства ассоциации на диаграмме классов" width="360" height="193">
					<figcaption>Рисунок 3.15</figcaption>
				</figure>
				<p>
					Действительно, перед началом трудовых отношений работник и работодатель подписывают между 
					собой контракт, который имеет такие атрибуты, как, например, описание работ, сроки их 
					выполнения, порядок оплаты и т. д.
				</p>
				<p>
					А вот более сложный, но, опять-таки, взятый из реальной жизни пример моделирования 
					отношений между классами, позаимствованный нами из Zicom Mentor (рис. 3.16):
				</p>
				<figure>
					<img src="index_class_diagram/03_16_uml.gif" alt="picture is missing" title="Пример моделирования отношений между классами" width="610" height="420">
					<figcaption>Рисунок 3.16</figcaption>
				</figure>
				<p>
					И наконец, доказательство того, что UML можно использовать для чего угодно, в том числе 
					и для записи сказок: диаграмма, описывающая предметную область сказки о Курочке Рябе и 
					взятая с сайта <a href="http://www.umljokes.com/" target="_blank" title="www.umljokes.com"> конкурса шуток на UML</a> (рис. 3.17):
				</p>
				<figure>
					<img src="index_class_diagram/03_16_uml.gif" alt="picture is missing" title="Предметная область сказки о Курочке Рябе" width="501" height="428">
					<figcaption>Рисунок 3.16</figcaption>
				</figure>
				<p>
					Узнаете рассказ, знакомый с детства?
				</p>
			</section>
			<section>
				<h3>Выводы</h3>
				<ul>
					<li>
						<em>Инкапсуляция</em> защищает внутреннее устройство объекта и реализуется путем ограничения 
						доступа к атрибутам и операциям класса из других частей программы;
					</li>
					<li>
						<em>Обобщение</em> позволяет повторно использовать уже существующие решения, создавая 
						новые классы путем наследования от имеющихся классов;
					</li>
					<li>
						<em>Полиморфизм</em> позволяет работать с группой разнородных объектов одинаковым образом, 
						не задумываясь о различиях в реализации;
					</li>
					<li>
						Инкапсуляция, наследование и полиморфизм - три кита, на которых держится 
						<abbr title="Объектно-ориентированное программирование">ООП</abbr>;
					</li>
					<li>В любой системе между объектами существуют отношения разных типов;</li>
					<li>
						<em>Отношение зависимости</em> означает, что реализация одного класса зависит от 
						спецификации операций другого класса;
					</li>
					<li>
						<em>Ассоциация</em> выражает отношение между несколькими равноправными объектами и 
						может иметь направление, роли и кратность, а также изображаться в виде класса ассоциации;
					</li>
					<li>
						<em>Композиция</em> и <em>агрегация</em> используются, если между объектами существуют 
						отношения типа <q>часть-целое</q>, причем композиция предполагает, что части не могут 
						существовать отдельно от целого.
					</li>
				</ul>
			</section>
		</div>
		
		<footer role="contentinfo">
			<hr/>
			<p>Оформление страницы <a href="sobolandrey.by"  target="_blank" title="Перейти на веб-сайт">sobolandrey.by</a></p>
			<p>&copy; 2015</p>
		</footer>
		
		<aside role="complementary">
			<nav role="navigation">
				<ul>
					<li class='aside_pointer'> <span id="span_aside">навигация</span></li>
						<ul>
							<li class='main_page'>Для перехода на <br> <a href='index.html'>стартовую</a> страницу</li>
						</ul>
					<li class='aside_pointer'> <span>содержание</span></li>
						<ul>
							<li class='high_nav'><a href='index_what_is_uml.html'>Что такое UML</a></li>
							<li class='high_nav'><a href='index_kinds_of_diagrams.html'>Виды диаграмм</a></li>
							<li class='high_nav'><a href='index_class_diagram.html'>Диаграмма классов</a></li>
							<li class='high_nav'><a href='index_activity_diagrams.html'>Диаграммы активностей</a></li>
							<li class='high_nav'><a href='index_interaction_diagrams.html'>Диаграммы взаимодействия</a></li>
							<li class='high_nav'><a href='index_use_case_diagram.html'>Диаграммы прецедентов</a></li>
							<li class='high_nav'><a href='index_case_tools.html'>Обзор CASE-средств для построения диаграмм UML</a></li>
						</ul>
					<li class='aside_pointer'><span>полезное</span></li>
						<ul>
							<li class='low_nav'><a href='http://www.intuit.ru/' target='_blank'>НОУ «ИНТУИТ»</a></li>
							<li class='low_nav'><a href='http://www.omg.org/' target='_blank'>Object Managment Group</a></li>
							<li class='low_nav'><a href='http://www.sparxsystems.com.au/' target='_blank'>Словарь-ассистент UML 2.0	</a></li>
						</ul>
				</ul>
			</nav>
			<div id="extra2" role="presentation"></div>
			<div id="extra3" role="presentation"></div>
		</aside>
		<div id="top"> <i class="fa fa-angle-double-up"></i> </div>
	</div>
		
	<div id="extra1" role="presentation"></div>
	<div id="extra4" role="presentation"></div>
	
	<!--[if lt IE 9]>
	<script src="libs/html5shiv/es5-shim.min.js"></script>
	<script src="libs/html5shiv/html5shiv.min.js"></script>
	<script src="libs/html5shiv/html5shiv-printshiv.min.js"></script>
	<script src="libs/respond/respond.min.js"></script>
	<![endif]-->
	<script src="libs/jquery/jquery-1.11.1.min.js"></script>
	<script src="js/common.js"></script>
	<!-- Yandex.Metrika counter --><!-- /Yandex.Metrika counter -->
	<!-- Google Analytics counter --><!-- /Google Analytics counter -->
</body>
</html>